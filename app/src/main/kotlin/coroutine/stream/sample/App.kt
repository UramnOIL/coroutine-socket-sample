/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package coroutine.stream.sample

import kotlinx.coroutines.*
import java.io.BufferedReader
import java.io.BufferedWriter
import java.io.IOException
import java.io.InputStreamReader
import java.io.OutputStreamWriter
import java.io.PrintWriter
import java.net.InetSocketAddress
import java.net.ServerSocket
import java.net.Socket
import kotlin.coroutines.CoroutineContext
import kotlin.coroutines.coroutineContext

class Session(val socket: Socket, coroutineContext: CoroutineContext, val onClose: Session.() -> Unit): CoroutineScope by CoroutineScope(SupervisorJob() + coroutineContext) {

    fun start() {
        val stream = BufferedReader(InputStreamReader(socket.getInputStream()))

        val job = launch {
            while (true) {
                val message = try {
                    withContext(Dispatchers.IO) {
                        stream.readLine()
                    }
                } catch (e: IOException) {
                    // readLine()でブロックしている最中に通信が切断したことを知れる
                    null
                }
                // messageがnullだった場合、接続が切れているとみなす
                message?.let { println(it) } ?: break
            }
            println("Socket closed!")
        }

        // Job終了時に呼ばれる処理
        // リソースの後片付けを行う
        job.invokeOnCompletion {
            if (!socket.isClosed) {
                close()
            }
        }
    }

    fun close() {
        // socket.close()でもcoroutineContext.cancelChildren()でもソケットを閉じることができる
        // お作法的には両方閉じる
        socket.close()
        coroutineContext.cancelChildren()

        onClose()
    }
}

class Client(val address: InetSocketAddress, coroutineContext: CoroutineContext): CoroutineScope by CoroutineScope(coroutineContext + SupervisorJob()) {
    private val socket = Socket()
    lateinit var stream: PrintWriter

    suspend fun connect() {
        withContext(Dispatchers.IO) {
            socket.connect(address)
        }
        socket.reuseAddress = true
        stream = withContext(Dispatchers.IO) {
            PrintWriter(socket.getOutputStream(), true)
        }
    }

    fun writeLine(message: String) {
        stream.println(message)
    }

    fun close() {
        coroutineContext.cancelChildren()
        socket.close()
    }
}

fun main() {
    // セッション管理用セット
    val sessions = mutableSetOf<Session>()

    // ソケット作成 & Listen開始
    val serverSocket = ServerSocket()
    serverSocket.reuseAddress = true
    serverSocket.bind(InetSocketAddress("0.0.0.0", 19132))

    // クライアント実行
    CoroutineScope(Dispatchers.Default).launch {
        // 接続
        val client = Client(InetSocketAddress("localhost", 19132), Dispatchers.IO)
        client.connect()

        // 10回書き込み
        repeat(10) {
            delay(1000 * 1)
            client.writeLine("$it")
        }

        // 切断
        client.close()
    }

    // 受け入れ
    val socket = serverSocket.accept()

    // セッション開始
    val session = Session(socket, Dispatchers.IO) {
        sessions.remove(this)
    }
    sessions.add(session)
    session.start()

    println("input enter key to stop server...")
    readLine()

    // すべてのセッションを終了させる
    sessions.forEach { it.close() }

    // ソケットを閉じる
    serverSocket.close()
}
